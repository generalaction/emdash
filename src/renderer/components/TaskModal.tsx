import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { Button } from './ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from './ui/dialog';
import { SlugInput } from './ui/slug-input';
import { Label } from './ui/label';
import { Spinner } from './ui/spinner';
import { Separator } from './ui/separator';
import { MultiProviderDropdown } from './MultiProviderDropdown';
import { TaskAdvancedSettings } from './TaskAdvancedSettings';
import { type Provider } from '../types';
import { type ProviderRun } from '../types/chat';
import { providerMeta } from '../providers/meta';
import { isValidProviderId } from '@shared/providers/registry';
import { type LinearIssueSummary } from '../types/linear';
import { type GitHubIssueSummary } from '../types/github';
import { type JiraIssueSummary } from '../types/jira';
import {
  generateFriendlyTaskName,
  normalizeTaskName,
  MAX_TASK_NAME_LENGTH,
} from '../lib/taskNames';
import { useGithubAuth } from '../hooks/useGithubAuth';

const DEFAULT_PROVIDER: Provider = 'claude';

interface TaskModalProps {
  isOpen: boolean;
  onClose: () => void;
  onCreateTask: (
    name: string,
    initialPrompt?: string,
    providerRuns?: ProviderRun[],
    linkedLinearIssue?: LinearIssueSummary | null,
    linkedGithubIssue?: GitHubIssueSummary | null,
    linkedJiraIssue?: JiraIssueSummary | null,
    autoApprove?: boolean,
    useWorktree?: boolean
  ) => void;
  projectName: string;
  defaultBranch: string;
  existingNames?: string[];
  projectPath?: string;
}

const TaskModal: React.FC<TaskModalProps> = ({
  isOpen,
  onClose,
  onCreateTask,
  projectName,
  defaultBranch,
  existingNames = [],
  projectPath,
}) => {
  const [taskName, setTaskName] = useState('');
  const [defaultProviderFromSettings, setDefaultProviderFromSettings] =
    useState<Provider>(DEFAULT_PROVIDER);
  const [providerRuns, setProviderRuns] = useState<ProviderRun[]>([
    { provider: DEFAULT_PROVIDER, runs: 1 },
  ]);
  const [autoGeneratedName, setAutoGeneratedName] = useState<string>('');
  const [customNameTracked, setCustomNameTracked] = useState(false);
  const userHasTypedRef = useRef(false);
  const isInitialSetupRef = useRef(true);
  const [isCreating, setIsCreating] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [touched, setTouched] = useState(false);
  const [initialPrompt, setInitialPrompt] = useState('');
  const [selectedLinearIssue, setSelectedLinearIssue] = useState<LinearIssueSummary | null>(null);
  const [selectedGithubIssue, setSelectedGithubIssue] = useState<GitHubIssueSummary | null>(null);
  const [selectedJiraIssue, setSelectedJiraIssue] = useState<JiraIssueSummary | null>(null);
  const [isJiraConnected, setIsJiraConnected] = useState<boolean | null>(null);
  const [isLinearConnected, setIsLinearConnected] = useState<boolean | null>(null);
  const [autoApprove, setAutoApprove] = useState(false);
  const [useWorktree, setUseWorktree] = useState(true);
  const autoNameInitializedRef = useRef(false);

  // GitHub connection state
  const {
    installed: githubInstalled,
    authenticated: githubAuthenticated,
    login: githubLogin,
    isLoading: githubLoading,
  } = useGithubAuth();
  const isGithubConnected = githubInstalled && githubAuthenticated;

  // Computed values
  const activeProviders = useMemo(() => providerRuns.map((pr) => pr.provider), [providerRuns]);
  const hasAutoApproveSupport =
    activeProviders.length > 0 &&
    activeProviders.every((providerId) => !!providerMeta[providerId]?.autoApproveFlag);
  const hasInitialPromptSupport =
    activeProviders.length > 0 &&
    activeProviders.every(
      (providerId) => providerMeta[providerId]?.initialPromptFlag !== undefined
    );

  // Clear issues and prompt when provider changes to one without support
  useEffect(() => {
    if (!hasInitialPromptSupport) {
      setSelectedLinearIssue(null);
      setSelectedGithubIssue(null);
      setSelectedJiraIssue(null);
      setInitialPrompt('');
    }
  }, [hasInitialPromptSupport]);

  const normalizedExisting = useMemo(
    () => existingNames.map((n) => normalizeTaskName(n)).filter(Boolean),
    [existingNames]
  );

  const validate = useCallback(
    (value: string): string | null => {
      const normalized = normalizeTaskName(value);
      if (!normalized) return 'Please enter a Task name.';
      if (normalizedExisting.includes(normalized)) {
        return 'A Task with this name already exists.';
      }
      if (normalized.length > MAX_TASK_NAME_LENGTH) {
        return `Task name is too long (max ${MAX_TASK_NAME_LENGTH} characters).`;
      }
      return null;
    },
    [normalizedExisting]
  );

  const onChange = (val: string) => {
    setTaskName(val);
    setError(validate(val));
    if (!isInitialSetupRef.current) {
      userHasTypedRef.current = true;
    }
    if (
      !customNameTracked &&
      autoGeneratedName &&
      val !== autoGeneratedName &&
      val.trim() &&
      normalizeTaskName(val) !== normalizeTaskName(autoGeneratedName)
    ) {
      setCustomNameTracked(true);
      void (async () => {
        const { captureTelemetry } = await import('../lib/telemetryClient');
        captureTelemetry('task_custom_named', { custom_name: 'true' });
      })();
    }
  };

  useEffect(() => {
    if (!isOpen) return;

    // Reset all form state on open
    setTaskName('');
    setAutoGeneratedName('');
    setError(null);
    setTouched(false);
    setCustomNameTracked(false);
    setInitialPrompt('');
    setSelectedLinearIssue(null);
    setSelectedGithubIssue(null);
    setSelectedJiraIssue(null);
    setAutoApprove(false);
    setUseWorktree(true);
    userHasTypedRef.current = false;
    isInitialSetupRef.current = false;
    autoNameInitializedRef.current = false;

    const suggested = generateFriendlyTaskName(normalizedExisting);
    const applySuggestedName = () => {
      if (userHasTypedRef.current) return;
      setAutoGeneratedName(suggested);
      setTaskName((prev) => {
        if (prev) return prev;
        setError(validate(suggested));
        return suggested;
      });
      autoNameInitializedRef.current = true;
    };
    applySuggestedName();

    let cancel = false;
    window.electronAPI.getSettings().then((res) => {
      if (cancel) return;
      const settings = res?.success ? res.settings : undefined;

      const settingsProvider = settings?.defaultProvider;
      const defaultProvider: Provider = isValidProviderId(settingsProvider)
        ? (settingsProvider as Provider)
        : DEFAULT_PROVIDER;
      setDefaultProviderFromSettings(defaultProvider);
      setProviderRuns([{ provider: defaultProvider, runs: 1 }]);

      const autoApproveByDefault = settings?.tasks?.autoApproveByDefault ?? false;
      setAutoApprove(autoApproveByDefault && !!providerMeta[defaultProvider]?.autoApproveFlag);

      const autoGenerate = settings?.tasks?.autoGenerateName ?? true;
      if (!autoNameInitializedRef.current && !userHasTypedRef.current && !taskName) {
        if (!autoGenerate) {
          setAutoGeneratedName('');
          setTaskName('');
          setError(null);
        } else {
          setAutoGeneratedName(suggested);
          setTaskName((prev) => {
            if (prev) return prev;
            setError(validate(suggested));
            return suggested;
          });
        }
        autoNameInitializedRef.current = true;
      }
    });
    return () => {
      cancel = true;
    };
  }, [isOpen]);

  // Check Linear connection when modal opens
  useEffect(() => {
    if (!isOpen) return;
    let cancel = false;
    const api: any = (window as any).electronAPI;
    if (!api?.linearCheckConnection) {
      setIsLinearConnected(false);
      return;
    }
    api
      .linearCheckConnection()
      .then((res: any) => {
        if (!cancel) setIsLinearConnected(!!res?.connected);
      })
      .catch(() => {
        if (!cancel) setIsLinearConnected(false);
      });
    return () => {
      cancel = true;
    };
  }, [isOpen]);

  // Check Jira connection when modal opens
  useEffect(() => {
    if (!isOpen) return;
    let cancel = false;
    const api: any = (window as any).electronAPI;
    api
      ?.jiraCheckConnection?.()
      .then((res: any) => {
        if (!cancel) setIsJiraConnected(!!res?.connected);
      })
      .catch(() => {
        if (!cancel) setIsJiraConnected(false);
      });
    return () => {
      cancel = true;
    };
  }, [isOpen]);

  const handleLinearConnect = useCallback(async (apiKey: string) => {
    if (!apiKey || !window?.electronAPI?.linearSaveToken) {
      throw new Error('Invalid API key');
    }
    const result = await window.electronAPI.linearSaveToken(apiKey);
    if (result?.success) {
      setIsLinearConnected(true);
    } else {
      throw new Error(result?.error || 'Could not connect Linear. Try again.');
    }
  }, []);

  const handleGithubConnect = useCallback(async () => {
    if (!githubInstalled) {
      try {
        await window.electronAPI.openExternal('https://cli.github.com/manual/installation');
      } catch (error) {
        console.error('Failed to open GitHub CLI install docs:', error);
      }
      return;
    }
    await githubLogin();
  }, [githubInstalled, githubLogin]);

  const handleJiraConnect = useCallback(
    async (credentials: { site: string; email: string; token: string }) => {
      const api: any = (window as any).electronAPI;
      const res = await api?.jiraSaveCredentials?.(credentials);
      if (res?.success) {
        setIsJiraConnected(true);
      } else {
        throw new Error(res?.error || 'Failed to connect.');
      }
    },
    []
  );

  useEffect(() => {
    if (!hasAutoApproveSupport && autoApprove) {
      setAutoApprove(false);
    }
  }, [hasAutoApproveSupport, autoApprove]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setTouched(true);
    userHasTypedRef.current = true;
    autoNameInitializedRef.current = true;
    const err = validate(taskName);
    if (err) {
      setError(err);
      return;
    }
    setIsCreating(true);
    try {
      const trimmedPrompt = initialPrompt.trim();
      await onCreateTask(
        normalizeTaskName(taskName),
        hasInitialPromptSupport && trimmedPrompt ? trimmedPrompt : undefined,
        providerRuns,
        selectedLinearIssue,
        selectedGithubIssue,
        selectedJiraIssue,
        hasAutoApproveSupport ? autoApprove : false,
        useWorktree
      );
      onClose();
    } catch (error) {
      console.error('Failed to create task:', error);
    } finally {
      setIsCreating(false);
    }
  };

  const handleOpenChange = (open: boolean) => {
    if (!open && isCreating) return;
    if (!open) onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogContent className="max-h-[calc(100vh-48px)] max-w-md overflow-y-auto">
        <DialogHeader>
          <DialogTitle>New Task</DialogTitle>
          <DialogDescription className="text-xs">
            {projectName} â€¢ from origin/{defaultBranch}
          </DialogDescription>
        </DialogHeader>

        <Separator />

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <Label htmlFor="task-name" className="mb-2 block">
              Task name
            </Label>
            <SlugInput
              id="task-name"
              value={taskName}
              onChange={onChange}
              onBlur={() => setTouched(true)}
              placeholder="refactor-api-routes"
              maxLength={MAX_TASK_NAME_LENGTH}
              className={`w-full ${touched && error ? 'border-destructive focus-visible:border-destructive focus-visible:ring-destructive' : ''}`}
              aria-invalid={touched && !!error}
              aria-describedby="task-name-error"
              autoFocus
            />
            {touched && error && (
              <p id="task-name-error" className="mt-1 text-xs text-destructive">
                {error}
              </p>
            )}
          </div>

          <div className="flex items-center gap-4">
            <Label className="shrink-0">AI Provider</Label>
            <MultiProviderDropdown
              providerRuns={providerRuns}
              onChange={setProviderRuns}
              defaultProvider={defaultProviderFromSettings}
            />
          </div>

          <TaskAdvancedSettings
            isOpen={isOpen}
            projectPath={projectPath}
            useWorktree={useWorktree}
            onUseWorktreeChange={setUseWorktree}
            autoApprove={autoApprove}
            onAutoApproveChange={setAutoApprove}
            hasAutoApproveSupport={hasAutoApproveSupport}
            initialPrompt={initialPrompt}
            onInitialPromptChange={setInitialPrompt}
            hasInitialPromptSupport={hasInitialPromptSupport}
            selectedLinearIssue={selectedLinearIssue}
            onLinearIssueChange={setSelectedLinearIssue}
            isLinearConnected={isLinearConnected}
            onLinearConnect={handleLinearConnect}
            selectedGithubIssue={selectedGithubIssue}
            onGithubIssueChange={setSelectedGithubIssue}
            isGithubConnected={isGithubConnected}
            onGithubConnect={handleGithubConnect}
            githubLoading={githubLoading}
            githubInstalled={githubInstalled}
            selectedJiraIssue={selectedJiraIssue}
            onJiraIssueChange={setSelectedJiraIssue}
            isJiraConnected={isJiraConnected}
            onJiraConnect={handleJiraConnect}
          />

          <div className="flex justify-end">
            <Button type="submit" disabled={!!validate(taskName) || isCreating}>
              {isCreating ? (
                <>
                  <Spinner size="sm" className="mr-2" />
                  Creating...
                </>
              ) : (
                'Create'
              )}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
};

export default TaskModal;
