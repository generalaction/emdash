import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { Button } from './ui/button';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from './ui/dialog';
import { SlugInput } from './ui/slug-input';
import { Label } from './ui/label';
import { Spinner } from './ui/spinner';
import { Separator } from './ui/separator';
import { MultiAgentDropdown } from './MultiAgentDropdown';
import { TaskAdvancedSettings } from './TaskAdvancedSettings';
import { useIntegrationStatus } from './hooks/useIntegrationStatus';
import { type Agent } from '../types';
import { type AgentRun } from '../types/chat';
import { agentMeta } from '../providers/meta';
import { isValidProviderId } from '@shared/providers/registry';
import { type LinearIssueSummary } from '../types/linear';
import { type GitHubIssueSummary } from '../types/github';
import { type GitHubIssueLink } from '../types/chat';
import { type JiraIssueSummary } from '../types/jira';
import {
  generateFriendlyTaskName,
  normalizeTaskName,
  MAX_TASK_NAME_LENGTH,
} from '../lib/taskNames';
import BranchSelect, { type BranchOption } from './BranchSelect';

const DEFAULT_AGENT: Agent = 'claude';

interface TaskModalProps {
  isOpen: boolean;
  onClose: () => void;
  onCreateTask: (
    name: string,
    initialPrompt?: string,
    agentRuns?: AgentRun[],
    linkedLinearIssue?: LinearIssueSummary | null,
    linkedGithubIssue?: GitHubIssueSummary | null,
    linkedJiraIssue?: JiraIssueSummary | null,
    autoApprove?: boolean,
    useWorktree?: boolean,
    baseRef?: string,
    zenflow?: {
      enabled: boolean;
      template: 'spec-and-build' | 'full-sdd';
      featureDescription: string;
    }
  ) => void;
  projectName: string;
  defaultBranch: string;
  existingNames?: string[];
  linkedGithubIssueMap?: ReadonlyMap<number, GitHubIssueLink>;
  projectPath?: string;
  branchOptions?: BranchOption[];
  isLoadingBranches?: boolean;
}

const TaskModal: React.FC<TaskModalProps> = ({
  isOpen,
  onClose,
  onCreateTask,
  projectName,
  defaultBranch,
  existingNames = [],
  linkedGithubIssueMap,
  projectPath,
  branchOptions = [],
  isLoadingBranches = false,
}) => {
  // Form state
  const [taskName, setTaskName] = useState('');
  const [agentRuns, setAgentRuns] = useState<AgentRun[]>([{ agent: DEFAULT_AGENT, runs: 1 }]);
  const [error, setError] = useState<string | null>(null);
  const [touched, setTouched] = useState(false);
  const [isFocused, setIsFocused] = useState(false);

  // Advanced settings state
  const [initialPrompt, setInitialPrompt] = useState('');
  const [selectedLinearIssue, setSelectedLinearIssue] = useState<LinearIssueSummary | null>(null);
  const [selectedGithubIssue, setSelectedGithubIssue] = useState<GitHubIssueSummary | null>(null);
  const [selectedJiraIssue, setSelectedJiraIssue] = useState<JiraIssueSummary | null>(null);
  const [autoApprove, setAutoApprove] = useState(false);
  const [useWorktree, setUseWorktree] = useState(true);

  // Zenflow workflow state
  const [zenflowEnabled, setZenflowEnabled] = useState(false);
  const [zenflowTemplate, setZenflowTemplate] = useState<'spec-and-build' | 'full-sdd'>(
    'spec-and-build'
  );
  const [zenflowDescription, setZenflowDescription] = useState('');

  // Branch selection state - sync with defaultBranch unless user manually changed it
  const [selectedBranch, setSelectedBranch] = useState(defaultBranch);
  const userChangedBranchRef = useRef(false);
  const taskNameInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    if (isOpen && !userChangedBranchRef.current) {
      setSelectedBranch(defaultBranch);
    }
  }, [isOpen, defaultBranch]);

  const handleBranchChange = (value: string) => {
    setSelectedBranch(value);
    userChangedBranchRef.current = true;
  };

  // Auto-name tracking
  const [autoGeneratedName, setAutoGeneratedName] = useState('');
  const userHasTypedRef = useRef(false);
  const autoNameInitializedRef = useRef(false);
  const customNameTrackedRef = useRef(false);

  // Integration connections
  const integrations = useIntegrationStatus(isOpen);

  // Computed values
  const activeAgents = useMemo(() => agentRuns.map((ar) => ar.agent), [agentRuns]);
  const hasAutoApproveSupport = activeAgents.every((id) => !!agentMeta[id]?.autoApproveFlag);
  const hasInitialPromptSupport = activeAgents.every(
    (id) => agentMeta[id]?.initialPromptFlag !== undefined
  );

  const normalizedExisting = useMemo(
    () => existingNames.map((n) => normalizeTaskName(n)).filter(Boolean),
    [existingNames]
  );

  // Validation
  const validate = useCallback(
    (value: string): string | null => {
      const normalized = normalizeTaskName(value);
      if (!normalized) return 'Please enter a Task name.';
      if (normalizedExisting.includes(normalized)) return 'A Task with this name already exists.';
      if (normalized.length > MAX_TASK_NAME_LENGTH)
        return `Task name is too long (max ${MAX_TASK_NAME_LENGTH} characters).`;
      return null;
    },
    [normalizedExisting]
  );

  // Clear issues when provider doesn't support them
  useEffect(() => {
    if (!hasInitialPromptSupport) {
      setSelectedLinearIssue(null);
      setSelectedGithubIssue(null);
      setSelectedJiraIssue(null);
      setInitialPrompt('');
    }
  }, [hasInitialPromptSupport]);

  // Clear auto-approve if not supported
  useEffect(() => {
    if (!hasAutoApproveSupport && autoApprove) setAutoApprove(false);
  }, [hasAutoApproveSupport, autoApprove]);

  // Reset form and load settings when modal opens
  useEffect(() => {
    if (!isOpen) return;

    // Reset state
    setTaskName('');
    setAutoGeneratedName('');
    setError(null);
    setTouched(false);
    setIsFocused(false);
    setInitialPrompt('');
    setSelectedLinearIssue(null);
    setSelectedGithubIssue(null);
    setSelectedJiraIssue(null);
    setAutoApprove(false);
    setUseWorktree(true);
    setZenflowEnabled(false);
    setZenflowTemplate('spec-and-build');
    setZenflowDescription('');
    userHasTypedRef.current = false;
    autoNameInitializedRef.current = false;
    customNameTrackedRef.current = false;
    userChangedBranchRef.current = false;
    setSelectedBranch(defaultBranch);

    // Generate initial name
    const suggested = generateFriendlyTaskName(normalizedExisting);
    setAutoGeneratedName(suggested);
    setTaskName(suggested);
    setError(validate(suggested));
    autoNameInitializedRef.current = true;

    // Load settings
    let cancel = false;
    window.electronAPI.getSettings().then((res) => {
      if (cancel) return;
      const settings = res?.success ? res.settings : undefined;

      const settingsAgent = settings?.defaultProvider;
      const agent: Agent = isValidProviderId(settingsAgent)
        ? (settingsAgent as Agent)
        : DEFAULT_AGENT;
      setAgentRuns([{ agent, runs: 1 }]);

      const autoApproveByDefault = settings?.tasks?.autoApproveByDefault ?? false;
      setAutoApprove(autoApproveByDefault && !!agentMeta[agent]?.autoApproveFlag);

      // Handle auto-generate setting
      if (settings?.tasks?.autoGenerateName === false && !userHasTypedRef.current) {
        setAutoGeneratedName('');
        setTaskName('');
        setError(null);
      }
    });

    return () => {
      cancel = true;
    };
  }, [isOpen]);

  const handleNameChange = (val: string) => {
    setTaskName(val);
    setError(validate(val));
    userHasTypedRef.current = true;

    // Track custom naming for telemetry (only once per session)
    if (
      autoGeneratedName &&
      val !== autoGeneratedName &&
      val.trim() &&
      !customNameTrackedRef.current
    ) {
      customNameTrackedRef.current = true;
      void (async () => {
        const { captureTelemetry } = await import('../lib/telemetryClient');
        captureTelemetry('task_custom_named', { custom_name: 'true' });
      })();
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setTouched(true);

    const err = validate(taskName);
    if (err) {
      setError(err);
      return;
    }

    const normalizedTaskName = normalizeTaskName(taskName);

    // Close modal immediately - task creation happens in background
    // The task will appear in sidebar via optimistic UI update
    onClose();

    // Fire and forget - don't await
    try {
      // For zenflow, use the feature description as the initial prompt
      const effectivePrompt = zenflowEnabled
        ? zenflowDescription.trim() || undefined
        : hasInitialPromptSupport && initialPrompt.trim()
          ? initialPrompt.trim()
          : undefined;

      onCreateTask(
        normalizedTaskName,
        effectivePrompt,
        agentRuns,
        selectedLinearIssue,
        selectedGithubIssue,
        selectedJiraIssue,
        hasAutoApproveSupport ? autoApprove : false,
        useWorktree,
        selectedBranch,
        zenflowEnabled
          ? { enabled: true, template: zenflowTemplate, featureDescription: zenflowDescription }
          : undefined
      );
    } catch (error) {
      console.error('Failed to create task:', error);
    }
  };

  const handleOpenAutoFocus = useCallback((event: Event) => {
    event.preventDefault();
    taskNameInputRef.current?.focus({ preventScroll: true });
  }, []);

  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && onClose()}>
      <DialogContent
        className="max-h-[calc(100vh-48px)] max-w-md overflow-visible"
        onOpenAutoFocus={handleOpenAutoFocus}
      >
        <DialogHeader>
          <DialogTitle>New Task</DialogTitle>
          <DialogDescription className="text-xs">
            Create a task and open the agent workspace.
          </DialogDescription>
          <div className="space-y-1 pt-1">
            <p className="text-sm font-medium text-foreground">{projectName}</p>
            <div className="flex items-center gap-1.5">
              <span className="text-xs text-muted-foreground">from</span>
              {branchOptions.length > 0 ? (
                <BranchSelect
                  value={selectedBranch}
                  onValueChange={handleBranchChange}
                  options={branchOptions}
                  isLoading={isLoadingBranches}
                  variant="ghost"
                />
              ) : (
                <span className="text-xs text-muted-foreground">
                  {isLoadingBranches ? 'Loading...' : selectedBranch || defaultBranch}
                </span>
              )}
            </div>
          </div>
        </DialogHeader>

        <Separator />

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <Label htmlFor="task-name" className="mb-2 block">
              Task name
            </Label>
            <SlugInput
              ref={taskNameInputRef}
              id="task-name"
              value={taskName}
              onChange={handleNameChange}
              onFocus={() => setIsFocused(true)}
              onBlur={() => {
                setTouched(true);
                setIsFocused(false);
              }}
              placeholder="refactor-api-routes"
              maxLength={MAX_TASK_NAME_LENGTH}
              className={`w-full ${touched && error && !isFocused ? 'border-destructive focus-visible:border-destructive focus-visible:ring-destructive' : ''}`}
              aria-invalid={touched && !!error && !isFocused}
            />
          </div>

          <div className="flex items-center gap-4">
            <Label className="shrink-0">Agent</Label>
            <MultiAgentDropdown agentRuns={agentRuns} onChange={setAgentRuns} />
          </div>

          {/* Zenflow Workflow Toggle */}
          <div className="space-y-2">
            <div className="flex items-center gap-2">
              <input
                type="checkbox"
                id="zenflow-toggle"
                checked={zenflowEnabled}
                onChange={(e) => setZenflowEnabled(e.target.checked)}
                className="h-4 w-4 rounded border-input"
              />
              <Label htmlFor="zenflow-toggle" className="cursor-pointer text-sm">
                Zenflow workflow
              </Label>
              <span className="text-[10px] text-muted-foreground">
                (step-by-step orchestration)
              </span>
            </div>

            {zenflowEnabled && (
              <div className="space-y-2 rounded-md border bg-muted/30 p-3">
                <div className="flex gap-2">
                  <button
                    type="button"
                    className={`rounded-md px-3 py-1.5 text-xs font-medium transition-colors ${
                      zenflowTemplate === 'spec-and-build'
                        ? 'bg-primary text-primary-foreground'
                        : 'bg-muted text-muted-foreground hover:bg-accent'
                    }`}
                    onClick={() => setZenflowTemplate('spec-and-build')}
                  >
                    Spec & Build
                  </button>
                  <button
                    type="button"
                    className={`rounded-md px-3 py-1.5 text-xs font-medium transition-colors ${
                      zenflowTemplate === 'full-sdd'
                        ? 'bg-primary text-primary-foreground'
                        : 'bg-muted text-muted-foreground hover:bg-accent'
                    }`}
                    onClick={() => setZenflowTemplate('full-sdd')}
                  >
                    Full SDD
                  </button>
                </div>
                <p className="text-[11px] text-muted-foreground">
                  {zenflowTemplate === 'spec-and-build'
                    ? 'Write a tech spec, then implement. Good for medium tasks.'
                    : 'Requirements, tech spec, planning, then implement. Good for complex features.'}
                </p>
                <div>
                  <Label htmlFor="zenflow-desc" className="mb-1 block text-xs">
                    Feature description
                  </Label>
                  <textarea
                    id="zenflow-desc"
                    value={zenflowDescription}
                    onChange={(e) => setZenflowDescription(e.target.value)}
                    placeholder="Describe the feature you want to build..."
                    className="h-20 w-full rounded-md border bg-background px-3 py-2 text-sm placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring"
                  />
                </div>
              </div>
            )}
          </div>

          <TaskAdvancedSettings
            isOpen={isOpen}
            projectPath={projectPath}
            useWorktree={useWorktree}
            onUseWorktreeChange={setUseWorktree}
            autoApprove={autoApprove}
            onAutoApproveChange={setAutoApprove}
            hasAutoApproveSupport={hasAutoApproveSupport}
            initialPrompt={initialPrompt}
            onInitialPromptChange={setInitialPrompt}
            hasInitialPromptSupport={hasInitialPromptSupport}
            selectedLinearIssue={selectedLinearIssue}
            onLinearIssueChange={setSelectedLinearIssue}
            isLinearConnected={integrations.isLinearConnected}
            onLinearConnect={integrations.handleLinearConnect}
            selectedGithubIssue={selectedGithubIssue}
            onGithubIssueChange={setSelectedGithubIssue}
            linkedGithubIssueMap={linkedGithubIssueMap}
            isGithubConnected={integrations.isGithubConnected}
            onGithubConnect={integrations.handleGithubConnect}
            githubLoading={integrations.githubLoading}
            githubInstalled={integrations.githubInstalled}
            selectedJiraIssue={selectedJiraIssue}
            onJiraIssueChange={setSelectedJiraIssue}
            isJiraConnected={integrations.isJiraConnected}
            onJiraConnect={integrations.handleJiraConnect}
          />

          <DialogFooter>
            <Button type="submit" disabled={!!validate(taskName)}>
              Create
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
};

export default TaskModal;
